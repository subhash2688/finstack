<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Option B: Intelligence Pipeline</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #fff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; overflow-x: hidden; }

  .hero {
    position: relative;
    min-height: 100vh;
    background: linear-gradient(to bottom, #f9fafb, #fff);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  .hero-content {
    position: relative;
    z-index: 10;
    text-align: center;
    max-width: 700px;
    padding: 40px;
  }
  .hero-content h1 {
    font-size: 48px;
    font-weight: 700;
    color: #111;
    line-height: 1.15;
    margin-bottom: 16px;
  }
  .hero-content h1 span { color: #00B140; }
  .hero-content p { font-size: 16px; color: #6b7280; line-height: 1.6; }

  canvas#pipeline {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
  }

  .dark-section {
    position: relative;
    min-height: 100vh;
    background: #0a0a0a;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  .dark-section .hero-content h1 { color: #fff; }
  .dark-section .hero-content p { color: #9ca3af; }

  canvas#pipelineDark {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
  }

  .label {
    position: fixed;
    top: 20px;
    left: 20px;
    background: #00B140;
    color: #fff;
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    z-index: 100;
  }
</style>
</head>
<body>

<div class="label">Option B: Intelligence Pipeline</div>

<section class="hero">
  <canvas id="pipeline"></canvas>
  <div class="hero-content">
    <h1>The intelligence layer<br><span>for enterprise transformation.</span></h1>
    <p>Lighthouse integrates peer benchmarks, financial signals, and capability mapping to identify where AI drives the highest-return enterprise transformations.</p>
  </div>
</section>

<section class="dark-section">
  <canvas id="pipelineDark"></canvas>
  <div class="hero-content">
    <h1>A Structured <span>Intelligence Cycle</span></h1>
    <p>Every engagement flows through a defensible five-step transformation framework â€” from intake to board-ready output.</p>
  </div>
</section>

<script>
function initPipeline(canvasId, opts = {}) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  const isDark = opts.dark || false;

  let width, height, dpr;
  const streams = [];
  const particles = [];
  const STREAM_COUNT = 7;

  function resize() {
    dpr = devicePixelRatio;
    const rect = canvas.parentElement.getBoundingClientRect();
    width = rect.width;
    height = rect.height;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    createStreams();
  }

  function createStreams() {
    streams.length = 0;
    particles.length = 0;

    for (let i = 0; i < STREAM_COUNT; i++) {
      const yBase = (height * 0.1) + (height * 0.8) * (i / (STREAM_COUNT - 1));
      // Create control points for a flowing bezier curve
      const points = [];
      const segments = 4 + Math.floor(Math.random() * 3);
      for (let s = 0; s <= segments; s++) {
        points.push({
          x: (width * s) / segments,
          y: yBase + (Math.random() - 0.5) * height * 0.25,
          vy: (Math.random() - 0.5) * 0.15, // gentle vertical drift
          yBase: yBase + (Math.random() - 0.5) * height * 0.25,
          amplitude: 20 + Math.random() * 40,
          phase: Math.random() * Math.PI * 2,
          phaseSpeed: 0.005 + Math.random() * 0.01,
        });
      }

      streams.push({
        points,
        opacity: 0.03 + Math.random() * 0.05,
        width: 1 + Math.random() * 1.5,
        particleRate: 0.01 + Math.random() * 0.02,
      });
    }
  }

  function getPointOnStream(stream, t) {
    const pts = stream.points;
    const totalSegments = pts.length - 1;
    const segment = Math.min(Math.floor(t * totalSegments), totalSegments - 1);
    const localT = (t * totalSegments) - segment;

    const p0 = pts[Math.max(segment - 1, 0)];
    const p1 = pts[segment];
    const p2 = pts[Math.min(segment + 1, pts.length - 1)];
    const p3 = pts[Math.min(segment + 2, pts.length - 1)];

    // Catmull-Rom interpolation
    const t2 = localT * localT;
    const t3 = t2 * localT;
    const x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * localT +
      (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 +
      (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3);
    const y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * localT +
      (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
      (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3);

    return { x, y };
  }

  function update() {
    // Animate stream control points (gentle wave motion)
    for (const stream of streams) {
      for (const pt of stream.points) {
        pt.phase += pt.phaseSpeed;
        pt.y = pt.yBase + Math.sin(pt.phase) * pt.amplitude;
      }

      // Spawn particles
      if (Math.random() < stream.particleRate) {
        particles.push({
          stream: streams.indexOf(stream),
          t: 0,
          speed: 0.001 + Math.random() * 0.002,
          size: 2 + Math.random() * 3,
          brightness: 0.4 + Math.random() * 0.6,
        });
      }
    }

    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
      particles[i].t += particles[i].speed;
      if (particles[i].t > 1) particles.splice(i, 1);
    }
  }

  function draw() {
    ctx.clearRect(0, 0, width, height);

    // Draw streams (flowing curves)
    for (const stream of streams) {
      ctx.beginPath();
      const steps = 100;
      for (let s = 0; s <= steps; s++) {
        const t = s / steps;
        const pt = getPointOnStream(stream, t);
        if (s === 0) ctx.moveTo(pt.x, pt.y);
        else ctx.lineTo(pt.x, pt.y);
      }
      const strokeOpacity = isDark ? stream.opacity * 2.5 : stream.opacity;
      ctx.strokeStyle = `rgba(0,177,64,${strokeOpacity})`;
      ctx.lineWidth = stream.width;
      ctx.stroke();
    }

    // Draw particles (data signals traveling along streams)
    for (const p of particles) {
      const stream = streams[p.stream];
      if (!stream) continue;
      const pt = getPointOnStream(stream, p.t);

      // Glow
      const glowRadius = p.size * 5;
      const glow = ctx.createRadialGradient(pt.x, pt.y, 0, pt.x, pt.y, glowRadius);
      const glowOpacity = (isDark ? 0.3 : 0.15) * p.brightness;
      glow.addColorStop(0, `rgba(0,177,64,${glowOpacity})`);
      glow.addColorStop(1, 'rgba(0,177,64,0)');
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, glowRadius, 0, Math.PI * 2);
      ctx.fillStyle = glow;
      ctx.fill();

      // Trailing line
      const trailLen = 0.03;
      const trailStart = Math.max(0, p.t - trailLen);
      ctx.beginPath();
      const trailSteps = 15;
      for (let s = 0; s <= trailSteps; s++) {
        const tt = trailStart + (p.t - trailStart) * (s / trailSteps);
        const tpt = getPointOnStream(stream, tt);
        if (s === 0) ctx.moveTo(tpt.x, tpt.y);
        else ctx.lineTo(tpt.x, tpt.y);
      }
      const trailOpacity = isDark ? 0.4 : 0.2;
      ctx.strokeStyle = `rgba(0,177,64,${trailOpacity * p.brightness})`;
      ctx.lineWidth = p.size * 0.6;
      ctx.stroke();

      // Core dot
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, p.size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(0,177,64,${(isDark ? 0.7 : 0.4) * p.brightness})`;
      ctx.fill();
    }

    // Stage labels on the left/right edges
    const stageLabels = ['SEC Filings', 'Transcripts', 'Metrics', 'Peer Data', 'Signals', 'Insights', 'Strategy'];
    for (let i = 0; i < STREAM_COUNT; i++) {
      const stream = streams[i];
      if (!stream) continue;

      // Left label (input)
      const startPt = getPointOnStream(stream, 0.02);
      ctx.font = '9px -apple-system, sans-serif';
      ctx.fillStyle = isDark ? 'rgba(255,255,255,0.12)' : 'rgba(0,0,0,0.06)';
      ctx.textAlign = 'left';
      ctx.fillText(stageLabels[i] || '', startPt.x + 8, startPt.y + 3);
    }
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  window.addEventListener('resize', resize);
  resize();
  loop();
}

initPipeline('pipeline', { dark: false });
initPipeline('pipelineDark', { dark: true });
</script>
</body>
</html>
