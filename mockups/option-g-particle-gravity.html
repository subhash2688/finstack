<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Option G: Particle Gravity Field</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #fff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; overflow-x: hidden; }
  .hero {
    position: relative; min-height: 100vh; background: linear-gradient(to bottom, #f9fafb, #fff);
    display: flex; align-items: center; justify-content: center; overflow: hidden;
  }
  .hero-content {
    position: relative; z-index: 10; text-align: center; max-width: 700px; padding: 40px;
  }
  .hero-content h1 { font-size: 48px; font-weight: 700; color: #111; line-height: 1.15; margin-bottom: 16px; }
  .hero-content h1 span { color: #00B140; }
  .hero-content p { font-size: 16px; color: #6b7280; line-height: 1.6; }
  canvas { position: absolute; inset: 0; width: 100%; height: 100%; z-index: 1; }
  .dark-section {
    position: relative; min-height: 100vh; background: #0a0a0a;
    display: flex; align-items: center; justify-content: center; overflow: hidden;
  }
  .dark-section .hero-content h1 { color: #fff; }
  .dark-section .hero-content p { color: #9ca3af; }
  .label {
    position: fixed; top: 20px; left: 20px; background: #00B140; color: #fff;
    padding: 8px 16px; border-radius: 8px; font-size: 14px; font-weight: 600; z-index: 100;
  }
</style>
</head>
<body>
<div class="label">Option G: Particle Gravity Field</div>

<section class="hero">
  <canvas id="c1"></canvas>
  <div class="hero-content">
    <h1>The intelligence layer<br><span>for enterprise transformation.</span></h1>
    <p>Lighthouse integrates peer benchmarks, financial signals, and capability mapping to identify where AI drives the highest-return enterprise transformations.</p>
  </div>
</section>

<section class="dark-section">
  <canvas id="c2"></canvas>
  <div class="hero-content">
    <h1>A Structured <span>Intelligence Cycle</span></h1>
    <p>Every engagement flows through a defensible five-step transformation framework â€” from intake to board-ready output.</p>
  </div>
</section>

<script>
function initGravity(canvasId, opts = {}) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  const isDark = opts.dark || false;
  let W, H;
  const particles = [];
  const attractors = [];
  const PARTICLE_COUNT = 150;
  const ATTRACTOR_COUNT = 4;
  let time = 0;

  function resize() {
    const dpr = devicePixelRatio;
    const rect = canvas.parentElement.getBoundingClientRect();
    W = rect.width; H = rect.height;
    canvas.width = W * dpr; canvas.height = H * dpr;
    canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    if (particles.length === 0) init();
  }

  function init() {
    particles.length = 0;
    attractors.length = 0;

    // Create gravity wells (attractors) that orbit slowly
    for (let i = 0; i < ATTRACTOR_COUNT; i++) {
      attractors.push({
        cx: W * (0.2 + 0.6 * Math.random()),
        cy: H * (0.2 + 0.6 * Math.random()),
        orbitRadius: 50 + Math.random() * 100,
        orbitSpeed: 0.0002 + Math.random() * 0.0003,
        orbitPhase: Math.random() * Math.PI * 2,
        strength: 30 + Math.random() * 40,
        label: ['Diagnose', 'Benchmark', 'Quantify', 'Deploy'][i],
      });
    }

    // Create particles
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      particles.push({
        x: Math.random() * W,
        y: Math.random() * H,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        size: 1 + Math.random() * 2,
        trail: [],
        maxTrail: 8 + Math.floor(Math.random() * 12),
      });
    }
  }

  function update() {
    time++;

    // Update attractor positions (slow orbiting)
    for (const a of attractors) {
      a.x = a.cx + Math.cos(time * a.orbitSpeed + a.orbitPhase) * a.orbitRadius;
      a.y = a.cy + Math.sin(time * a.orbitSpeed + a.orbitPhase) * a.orbitRadius;
    }

    // Update particles
    for (const p of particles) {
      // Gravity from attractors
      for (const a of attractors) {
        const dx = a.x - p.x;
        const dy = a.y - p.y;
        const distSq = dx * dx + dy * dy;
        const dist = Math.sqrt(distSq);
        if (dist > 10) {
          const force = a.strength / (distSq + 500);
          p.vx += (dx / dist) * force;
          p.vy += (dy / dist) * force;
        }
      }

      // Damping
      p.vx *= 0.995;
      p.vy *= 0.995;

      // Speed limit
      const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
      if (speed > 2) {
        p.vx = (p.vx / speed) * 2;
        p.vy = (p.vy / speed) * 2;
      }

      p.x += p.vx;
      p.y += p.vy;

      // Wrap around
      if (p.x < -20) p.x = W + 20;
      if (p.x > W + 20) p.x = -20;
      if (p.y < -20) p.y = H + 20;
      if (p.y > H + 20) p.y = -20;

      // Trail
      p.trail.push({ x: p.x, y: p.y });
      if (p.trail.length > p.maxTrail) p.trail.shift();
    }
  }

  function draw() {
    ctx.clearRect(0, 0, W, H);

    // Draw connections between nearby particles
    const connDist = 80;
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const a = particles[i], b = particles[j];
        const dx = b.x - a.x, dy = b.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < connDist) {
          const opacity = (1 - dist / connDist) * (isDark ? 0.08 : 0.03);
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.strokeStyle = `rgba(0,177,64,${opacity})`;
          ctx.lineWidth = 0.5;
          ctx.stroke();
        }
      }
    }

    // Draw particle trails
    for (const p of particles) {
      if (p.trail.length < 2) continue;
      ctx.beginPath();
      ctx.moveTo(p.trail[0].x, p.trail[0].y);
      for (let i = 1; i < p.trail.length; i++) {
        ctx.lineTo(p.trail[i].x, p.trail[i].y);
      }
      ctx.strokeStyle = isDark ? 'rgba(0,177,64,0.08)' : 'rgba(0,177,64,0.03)';
      ctx.lineWidth = p.size * 0.5;
      ctx.stroke();
    }

    // Draw particles
    for (const p of particles) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fillStyle = isDark ? 'rgba(0,177,64,0.3)' : 'rgba(0,177,64,0.12)';
      ctx.fill();
    }

    // Draw attractors
    for (const a of attractors) {
      // Large soft glow
      const g = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, 80);
      g.addColorStop(0, isDark ? 'rgba(0,177,64,0.12)' : 'rgba(0,177,64,0.05)');
      g.addColorStop(0.5, isDark ? 'rgba(0,177,64,0.04)' : 'rgba(0,177,64,0.02)');
      g.addColorStop(1, 'rgba(0,177,64,0)');
      ctx.beginPath();
      ctx.arc(a.x, a.y, 80, 0, Math.PI * 2);
      ctx.fillStyle = g;
      ctx.fill();

      // Core
      ctx.beginPath();
      ctx.arc(a.x, a.y, 4, 0, Math.PI * 2);
      ctx.fillStyle = isDark ? 'rgba(0,177,64,0.4)' : 'rgba(0,177,64,0.2)';
      ctx.fill();

      // Label
      ctx.font = '10px -apple-system, sans-serif';
      ctx.fillStyle = isDark ? 'rgba(0,177,64,0.2)' : 'rgba(0,177,64,0.1)';
      ctx.textAlign = 'center';
      ctx.fillText(a.label, a.x, a.y + 16);

      // Orbit ring
      ctx.beginPath();
      ctx.arc(a.cx, a.cy, a.orbitRadius, 0, Math.PI * 2);
      ctx.strokeStyle = isDark ? 'rgba(0,177,64,0.04)' : 'rgba(0,177,64,0.015)';
      ctx.lineWidth = 0.5;
      ctx.setLineDash([4, 8]);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  function loop() { update(); draw(); requestAnimationFrame(loop); }
  window.addEventListener('resize', resize);
  resize();
  loop();
}

initGravity('c1', { dark: false });
initGravity('c2', { dark: true });
</script>
</body>
</html>
